# React Reconciliation (리액트 재조정)

## 비교 알고리즘 (Diffing Algorithm)

### 1. 엘리먼트의 타입이 다른 경우

<a> 에서 <img> 등 두 루트 엘리먼트의 타입이 다르다면, 리액트는 이전 트리를 버리고 완전히 새로운 트리를 구축한다.

트리를 버릴 때 이전 DOM 노드들은 모두 파괴된다. 그리고 `componentWillUnmount` 함수가 실행되고, 새로운 트리를 만들기 때문에 `componentDidMount`가 이어서 실행된다. 이때 **이전 트리와 연관된 모든 state는 삭제된다.**

가령 아래처럼 `div`태그에서 `span`태그로 변경되면, 이전 `Counter`는 사라지고 새로 다시 마운트된다.

```jsx
<div>
  <Counter />
</div>
   ↓
<span>
  <Counter />
</span>
```

### 2. DOM 엘리먼트의 타입이 같은 경우

같은 타입의 DOM 엘리먼트인 경우는, 두 엘리먼트의 속성을 확인해 동일한 내역은 유지하고 변경된 속성들만 갱신한다.

```jsx
<div className="before" title="stuff" />
                 ↓
<div className="after" title="stuff" />
```

두 엘리먼트를 비교하면 className 속성만 변했기 때문에 이 값만 수정한다. 마찬가지로 styled이 갱신되었다면 이 속성값만 갱신해주면 된다.

해당 DOM 노드의 처리가 끝나면 자식 노드들에 대한 내용도 재귀적으로 처리한다.

### 3. 같은 타입의 컴포넌트 엘리먼트

컴포넌트가 갱신되면 인스턴스는 동일하게 유지되어 렌더링 간 state는 유지된다. 리액트는 새로운 엘리먼트의 내용을 반영하기 위해 **현재 컴포넌트 인스턴스의 props값을 갱신**해준다. 이때는 `componentDidUpdate`를 호출한다.

## 자식에 대한 재귀적 처리

DOM 노드의 자식들을 재귀적으로 처리할 때, 리액트는 기본적으로 동시에 두 리스트를 순회하고 차이점이 있으면 변경한다.

리스트를 순회할때는 리스트의 첫번째 값부터 순차적으로 확인을 하기 때문에 만약 리스트 마지막에 새로운 값이 추가된 경우라면 성능상 문제될 일이 없다.

그러나 아래처럼 리스트에 처음에 값이 추가되면 비효율적으로 동작하게 된다. 이렇게 되면 첫번째, 두번째, 세번째 리스트 값이 모두 달라진 것으로 판단이 되고 마지막에 새로운 값을 추가한것으로 인식하기 때문이다. 리액트는 key라는 속성을 이용해 이 문제를 해결한다.

```jsx
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
         ↓
<ul>
  **<li>Connecticut</li>**
  <li>Duke</li>
  <li>Villanova</li>
</ul>
```

### keys

만약 위 코드와 동일한데 이런 key 속성을 가지고 있다면 트리 변환작업이 효율적으로 수행될 수 있다.

이제는 React 2014 키를 가진 엘리먼트가 새로 추가되었고, 2015와 2016 키를 가진 엘리먼트는 그저 이동해주면 되기 때문이다.

**키값은 형제 사이에서만 유일하면 되고 전역으로 유일할 필요가 없다.** 그래서 아이템의 속성 값중 일부를 사용해주면 된다. 그러나 **배열의 인덱스나 랜덤한 값을 key로 이용할 경우에는 문제가 되는데, 배열의 index는 매번 변경되기 때문에 key가 없는 경우처럼 비효율적으로 동작될 수 있기 때문이다.**

그래서 항상 순수함수처럼 동작하는 유니크한 값을 키로 줘야한다.

```jsx
<ul>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>
         ↓
<ul>
  <li key="2014">Connecticut</li>
  <li key="2015">Duke</li>
  <li key="2016">Villanova</li>
</ul>
```

## 요약

- 리액트는 diffing 알고리즘을 통해 재조정 과정을 거친다.
- 엘리먼트가 다른 경우는 해당 컴포넌트를 완전히 언마운트 후에 다시 생성한다.
- 엘리먼트가 같은 경우는 두 엘리먼트의 속성을 확인 후 동일 내역을 유지하고 변경된 내용만 업데이트한다.
- key가 없다면 리액트는 이전 컴포넌트와 같은 컴포넌트인지 비교하기 어렵고, 이럴 경우 비효율적으로 리렌더링이 발생한다.