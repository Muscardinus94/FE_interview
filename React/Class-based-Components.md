# React - 클래스 컴포넌트(Class-based-Components)

## 설명

### 1. React 컴포넌트를 구성하는 방식

#### 1-1. 함수형 컴포넌트 구성방식

- 함수형 컴포넌트 구성방식은 현재 리액트에서 가장 기본적이고 현대적인 방식입니다. (React 16.8) 이후로 `React Hook`, `React Functional Components` 방식이 도입되었습니다. 그전에는 useState, useEffect와 같이 state를 관리하거나 컴포넌트 진행과정을 컨트롤 하기 위해서는 자바스크립트의 `class` 가 필요했습니다.

#### 2-1. 클래스 컴포넌트 구성방식

- 클래스 컴포넌트는 리액트 문법이 아닙니다. class라는 자바스크립트 문법으로 컴포넌트를 구성했는데 `render`라는 예약어로 `JSX` 코드를 반환했습니다. 위에서 설명했다시피 클래스 컴포넌트 구성방식에서는 `React Hook`을 사용할 수 없습니다. 하지만 두방식 모두 유효하기에 각 기능을 class 기반으로 변환 할수도 있습니다.

- 두 컴포넌트를 섞어서 사용해도 됩니다. 함수형 컴포넌트가 클래스 컴포넌트를 호출해서 반환해도 React는 문제없이 받아들입니다. 즉, 이들은 어디까지나 컴포넌트의 본연의 역할에 충실합니다. 하지만 보통 한가지 경우만 고집해서 사용합니다. React에서는 클래스 컴포넌트에서 함수형 컴포넌트로 단계적으로 마이그레이션하는 것을 추천하고 있습니다.

### 3. 기본적인 구성차이

- 클래스 컴포넌트에서는 `class`라는 자바스크립트 구조를 사용합니다. 그리고 안에서는 `render` 라는 예약어로 함수를 정의합니다. 이 함수에서 `return` 값은 함수형 컴포넌트의 `return`과 같습니다.

- `props`의 취급은 조심해야합니다. `this.props`로 모습을 바꿔줍니다. `class` 는 함수객체입니다. 따라서 `this`가 존재하는데 `Component` 라는 클래스를 상속받아 `this.props`도 존재합니다. 이런식으로 상위 컴포넌트의 props를 받아올수 있습니다.

### 4. state 관리 차이

- class형 컴포넌트에서는 상태관리를 모두 한객체에서 관리합니다. state라는 프로피터 객체로 관리되며 setState 메서드로 관리됩니다. 반드시 객체로 관리됩니다.
- 생성자함수 안에서 this.state 에 대한 초기 설정을 합니다.
- setState를 호출할때도 this를 이용해서 호출합니다. 한개의 상태변수가 있지만 여러개의 상태변수를 가지고 있어도 해당하는 상태변수만 명시합니다. 업데이트 될때 기존 상태의 스냅샷 객체와 리턴된 객체가 병합되기 때문입니다.
- JSX 안에서 class 메소드를 넘길경우에는 this 바인딩을 해줘야합니다. 메소드안의 this는 비어있기 때문에 해당메소드의 this는 현재 클래스의 this라는 것을 명시하기위해 bind 메소드로 바이딩을 해줍니다.

### 5. Class-based Component Lifecycle

- 함수형 컴포넌트는 훅을 사용할 수 없습니다. 따라서 `useEffect`와 같은 개념을 사용할 수 없습니다. 하지만 `Lifecycle` 이라는 개념이 있습니다.
- `componentDidMount()` : 컴포넌트가 마운트 될때 실행됩니다. 컴포넌트가 마운트 되었다는 것은 컴포넌트가 실행된다음 렌더링까지 된 상태라는 것을 의미합니다. `useEffect(..., [])` 이 개념과 동일합니다. 렌더링되고 나서 처음 실행되고 더이상은 실행되지 않습니다.
- `componentDidUpdate()` : 컴포넌트가 업데이트 될때 실행합니다. `useEffect(..., [someValue])` 개념과 동일합니다. 일부 종속성이 있으면 해당 변수가 변할때마다 실행됩니다.
- `componentWillUnmount()`: 컴포넌트가 제거되기전에 실행됩니다. `useEffect(()=>{return ()=> {}},[])` 의 클리너 함수와 같은 개념입니다. 이외에도 다양한 라이프 사이클 컨트롤 메서드들이 있습니다.

### 6. Class-based Component And Context

- 클래스 기반 컴포넌트에서는 훅을 사용하지 못하므로 `useContext`를 사용하지 못합니다. 하지만 두가지 방법으로 사용할 수 있습니다.

#### 6-1. **context.Consumer 사용하기**

   - context를 사용할 컴포넌트 안에 Consumer를 Wrapping하고 인라인 함수로 store를 인수로 받아 반환 값을 렌더합니다. context의 종류가 많아지면 계속 덮어씌우게 됩니다. 
   -이는 3개 이상만되어도 가독성이 너무나 떨어집니다.

#### 6-2. **static 키워드 사용하기**

- `static` 키워드는 정적 프로퍼티를 생성합니다. 
- 즉, contextType이라는 프로퍼티를 class 객체에 직접 할당한 것입니다.
- 이렇게 되면 `this.context` 라는 프로퍼티로 해당 컨텍스트에 접근가능합니다.
- 하지만 이방법은 제한이 있습니다. 하나의 컨텍스트 밖에 접근할수가 없습니다.
- 여러개의 컨텍스트에 접근하려면 상단의 방식으로 중첩 wrapping을 하면서 접근해야합니다.

### 7. Error Boundaries

- 에러 바운더리 라는 개념은 컴포넌트안에서 핸들링 하지 않은 에러가 생성되었을때 에러가 핸들링 될때까지 상위 컴포넌트로 올라가다가 ErrorBoundary 컴포넌트에서 핸들링 되는 개념입니다.
- 여기에는 `componentDidCatch` 함수가 사용되기 때문에 에러 바운더리 컴포넌트는 함수형 컴포넌트로 만들수 가 없습니다. 클래스 컴포넌트에서 작성됩니다.

## 요약

- 클래스 컴포넌트의 구성방식은 리액트 문법이 아닌 자바스크립트 문법인 class 구조로 구현됩니다.
- 클래스 컴포넌트는 함수는 메소드로 관리되며, props와 상태변수들은 Component 클래스에서 상속되는 this를 받아서 사용됩니다.
- 클래스 컴포넌트는 useEffect 훅 대신 Lifecycle로 불리는 메서드들을 이용해서 컴포넌트의 렌더링 시점과 실행단계를 조절합니다.
- 클래스 컴포넌트에서도 Context 사용이 가능하지만 번거롭습니다.
- 에러바운더리 라는 개념으로 최상단 컴포넌트단계에서 모든 컴포넌트들의 에러핸들링이 가능합니다. 다만 클래스 컴포넌트로 작성해야만 합니다.

## 참고

- [Udemy 강의](http://https://www.udemy.com/course/react-the-complete-guide-incl-redux/learn/lecture/25599684#content)
